use std::str::FromStr;

use nom::{
    branch::alt,
    bytes::complete::tag,
    character::complete::{char, digit1, space1},
    combinator::{map, map_res, opt, recognize, value},
    multi::many1,
    sequence::{delimited, pair, tuple},
    IResult,
};
use serde::Serialize;

use crate::{
    symbol::{parse_symbol, Symbol},
    util::ws,
    KconfigInput,
};

use super::function::{parse_function_call, FunctionCall};

// (GFS2_FS!=n) && NET && INET && (IPV6 || IPV6=n) && CONFIGFS_FS && SYSFS && (DLM=y || DLM=GFS2_FS)

#[derive(Debug, Serialize, PartialEq, Clone)]
pub enum Operator {
    And,
    Or,
}
impl Operator {
    fn to_string(&self) -> &str {
        match self {
            Operator::And => "&&",
            Operator::Or => "||",
        }
    }
}


#[derive(Debug, PartialEq, Serialize, Clone)]
pub enum CompareOperator {
    GreaterThan,
    GreaterOrEqual,
    LowerThan,
    LowerOrEqual,
    Equal,
    NotEqual,
}

#[derive(Debug, Serialize, PartialEq, Clone)]
pub enum Expression {
    Term(Term),
    Boolean(Term, Vec<Compare>),
}

#[derive(Debug, Serialize, PartialEq, Clone)]
pub struct Compare {
    pub operator: Operator,
    pub term: Term,
}

#[derive(Debug, PartialEq, Serialize, Clone)]
pub enum LeftOperand {
    Compare(Term, Operator),
}

pub fn parse_left_operand(input: KconfigInput) -> IResult<KconfigInput, LeftOperand> {
    let mut parser =  pair(ws(parse_term), ws(parse_operator));
    let (input, (t, operator)) = parser(input)?;

    let pp = ws(tag(operator.to_string()));

    let (input, ok) = many1(pair(parse_term, pp))(input)?;

    //map(pair(ws(parse_operator), ws(parse_term)), |(o, t)| {
    //    RightOperand::Compare(o, t)
    //})(input)
    Ok((input, LeftOperand::Compare(Term::Symbol(Symbol::Constant("h".to_string())), Operator::And)))
}


pub fn parse_right_operand(input: KconfigInput) -> IResult<KconfigInput, Compare> {
    /*map(pair(ws(parse_operator), ws(parse_term)), |(o, t)| {
        RightOperand::Compare(o, t)
    })(input)*/
    map(pair(ws(parse_operator), ws(parse_term)), |(o, t)| {
        Compare {operator: o, term: t}
    })(input)
}


pub trait Pouet {
    fn guess(&self) -> Option<Operator>;
    fn optimise(&self) -> Self;
}

impl Pouet for Term {
    fn guess(&self) -> Option<Operator> {
        match &self {
            Term::Not(e) => e.guess(),
            Term::Parenthesis(e) => e.guess(),
            _ => None
        }
    }

    fn optimise(&self) -> Self {
        return self.clone()
    }
}

impl Pouet for Expression {
    fn guess(&self) -> Option<Operator> {
        match &self {
            Expression::Term(t) => t.guess(),
            Expression::Boolean(_, t) => None,
        }
    }

    fn optimise(&self) -> Self {
        return self.clone()
    }
}

impl Pouet for Compare {
    fn guess(&self) -> Option<Operator> {
        let o = self.term.guess();
        match o {
            Some(_r) => None,
            None => return None,
        }
    }
    
    fn optimise(&self) -> Self {
        return self.clone()
    }
}


#[derive(Debug, Serialize, PartialEq, Clone)]
pub enum Term {
    Symbol(Symbol),
    Number(i64),
    Compare(Symbol, CompareOperator, Symbol),
    Not(Box<Expression>),
    Function(FunctionCall),
    Parenthesis(Box<Expression>),
}

impl Default for Expression {
    fn default() -> Self {
        Expression::Term(Default::default())
    }
}

impl Default for Term {
    fn default() -> Self {
        Self::Symbol(Default::default())
    }
}

pub fn parse_operator(input: KconfigInput) -> IResult<KconfigInput, Operator> {
    alt((
        value(Operator::And, tag("&&")),
        value(Operator::Or, tag("||")),
    ))(input)
}

pub fn parse_term(input: KconfigInput) -> IResult<KconfigInput, Term> {
    alt((
        map(pair(ws(tag("!")), parse_expression), |(_, o)| {
            Term::Not(Box::new(o))
        }),
        map(parse_function_call, Term::Function),
        map(
            delimited(ws(tag("(")), parse_expression, ws(tag(")"))),
            |expr| Term::Parenthesis(Box::new(expr)),
        ),
        ws(parse_compare),
        map(parse_symbol, Term::Symbol),
        map(parse_number, Term::Number),
    ))(input)
}

pub fn parse_expression(input: KconfigInput) -> IResult<KconfigInput, Expression> {
    alt((
        map(
            pair(ws(parse_term), many1(parse_right_operand)),
            |(l, o)| Expression::Boolean(l, o),
        ),
        //map(
        //    many1(parse_right_operand),
        //    |(l)| Expression::Boolean(l),
        //),
        map(ws(parse_term), Expression::Term)
    ))(input)
}

pub fn parse_compare_operator(input: KconfigInput) -> IResult<KconfigInput, CompareOperator> {
    alt((
        value(CompareOperator::GreaterOrEqual, tag(">=")),
        value(CompareOperator::LowerOrEqual, tag("<=")),
        value(CompareOperator::GreaterThan, tag(">")),
        value(CompareOperator::LowerThan, tag("<")),
        value(CompareOperator::Equal, tag("=")),
        value(CompareOperator::NotEqual, tag("!=")),
    ))(input)
}

pub fn parse_compare(input: KconfigInput) -> IResult<KconfigInput, Term> {
    map(tuple((parse_symbol, parse_compare_operator, parse_symbol)), |(l, o, r)| Term::Compare(l, o, r))(input)
}


pub fn parse_if_expression_attribute(input: KconfigInput) -> IResult<KconfigInput, Expression> {
    map(
        tuple((space1, tag("if"), ws(parse_expression))),
        |(_, _, e)| e,
    )(input)
}

pub fn parse_hex_number(input: KconfigInput) -> IResult<KconfigInput, i64> {
    map_res(
        recognize(pair(opt(char('-')), digit1)),
        |d: KconfigInput| FromStr::from_str(d.fragment()),
    )(input)
}

pub fn parse_number(input: KconfigInput) -> IResult<KconfigInput, i64> {
    map_res(
        recognize(pair(opt(char('-')), digit1)),
        |d: KconfigInput| FromStr::from_str(d.fragment()),
    )(input)
}

pub fn parse_if_expression(input: KconfigInput) -> IResult<KconfigInput, Expression> {
    map(pair(ws(tag("if")), ws(parse_expression)), |(_, e)| e)(input)
}
